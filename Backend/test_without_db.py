import json

# Your raw input
raw_json = {
  "response": "{\"type\": \"flashnotes\", \"body\": {\"notes\": [\n{\"note\": \"Recursion is a programming technique where a function calls itself in its definition.\"},\n{\"note\": \"A recursive function solves a problem by breaking it down into smaller instances of the same problem.\"},\n{\"note\": \"The base case is a trivial case that can be solved directly, stopping the recursion.\"},\n{\"note\": \"The recursive case is where the function calls itself with a smaller input or a modified version of the original input.\"},\n{\"note\": \"Recursion can be used to solve problems with a recursive structure, such as tree traversals or factorial calculations.\"},\n{\"note\": \"Each recursive call adds a layer to the system's call stack, which can lead to a stack overflow if not managed properly.\"},\n{\"note\": \"Tail recursion is a form of recursion where the last statement is the recursive call, allowing for optimization.\"},\n{\"note\": \"Some languages optimize for tail recursion, reusing the current stack frame for the recursive call.\"},\n{\"note\": \"Recursion can make code more readable and easier to understand for problems with a recursive nature.\"},\n{\"note\": \"However, recursion can be less efficient than iteration due to the overhead of function calls and stack management.\"},\n{\"note\": \"Examples of recursive algorithms include binary search, merge sort, and the Tower of Hanoi.\"},\n{\"note\": \"Understanding the base case and recursive case is crucial for writing a correct recursive function.\"},\n{\"note\": \"Recursion can be used in both functional and imperative programming paradigms.\"},\n{\"note\": \"Debugging recursive functions can be challenging due to their self-referential nature.\"},\n{\"note\": \"Memoization can be used to optimize recursive functions by caching the results of expensive function calls.\"},\n{\"note\": \"Recursion is not suitable for all problems, especially those with a large number of recursive calls.\"},\n{\"note\": \"Iterative solutions can sometimes be more efficient and scalable than recursive ones.\"},\n{\"note\": \"Recursion is a fundamental concept in computer science and is used in many algorithms and data structures.\"},\n{\"note\": \"Mastering recursion requires practice and understanding of how to apply it to different problems.\"},\n{\"note\": \"Recursion can be an elegant solution to certain problems, making the code more concise and intuitive.\"},\n{\"note\": \"However, it requires careful consideration of the base case and the recursive case to avoid infinite loops.\"},\n{\"note\": \"Recursion is closely related to the concept of induction in mathematics.\"},\n{\"note\": \"Understanding recursion helps in understanding more complex data structures like trees and graphs.\"},\n{\"note\": \"Recursion is a powerful tool for solving problems that have a recursive structure.\"},\n{\"note\": \"It allows for a more declarative programming style, focusing on the problem definition rather than the solution steps.\"},\n{\"note\": \"Recursion can simplify code by avoiding the need for explicit loops.\"},\n{\"note\": \"Despite its benefits, recursion should be used judiciously, considering the potential for stack overflow errors.\"},\n{\"note\": \"Recursion is a key concept in functional programming languages.\"},\n{\"note\": \"Many algorithms, such as those for traversing trees or graphs, rely heavily on recursion.\"}\n]}}"
}

# Step 1: Parse the outer dict (if it's a string, do json.loads(raw_json_string))
outer = raw_json

# Step 2: Parse the inner string under "response"
parsed_response = json.loads(outer["response"])

# Now you can access type and body
print(parsed_response["type"])          # flashnotes
print(parsed_response["body"]["notes"]) # list of note dicts